# 飓风内核

## 异步运行时实现

内核给异步运行时提供了`executor`的实现

> 不同的地址空间应该有不同的执行器

提供`run_until_idle`方法 运行应该执行的任务

有可能在当前地址空间 也可能不在当前地址空间

```rust
pub fn run_until_idle(
    peek_task: impl Fn() -> TaskResult,
    delete_task: impl Fn(usize) -> bool,
    set_task_state: impl Fn(usize, TaskState),
) {
    loop {
        ext_intr_off();// 关中断
        let task = peek_task(); //寻找当当前需要执行的任务
        ext_intr_on(); // 开中断
        // println!(">>> kernel executor: next task = {:x?}", task);
        match task {
            TaskResult::Task(task_repr) => {
                // 在相同的（内核）地址空间里面
                ext_intr_off(); 
                set_task_state(task_repr, TaskState::Sleeping); 
                ext_intr_on();
                let task: Arc<KernelTaskRepr> = unsafe { Arc::from_raw(task_repr as *mut _) };
                // 注册 waker
                let waker = waker_ref(&task);
                let mut context = Context::from_waker(&*waker);
                // 注册好Waker之后poll并开始执行 
                // 执行完之后如果返回Pending 那就代表还没有执行完
                // 否则是Ready 那就可以删除掉这个任务了
                let ret = task.task().future.lock().as_mut().poll(&mut context);
                if let Poll::Pending = ret {
                    mem::forget(task); // 不要释放task的内存，它将继续保存在内存中被使用
                } else {
                    // 否则，释放task的内存
                    ext_intr_off();
                    delete_task(task_repr);
                    ext_intr_on();
                } // 隐含一个drop(task)
            }
            TaskResult::ShouldYield(next_asid) => {
                // 当前要执行的任务不在当前地址空间
                // 不释放这个任务的内存，执行切换地址空间的系统调用
                mem::forget(task);
                let next_satp = KernelHartInfo::user_satp(next_asid).expect("get satp with asid");
                let swap_cx = unsafe { get_swap_cx(&next_satp, next_asid) };
                switch_to_user(swap_cx, next_satp.inner(), next_asid)
            }
            TaskResult::NoWakeTask => {
                // 没有醒着的任务，直接跳过
            }
            TaskResult::Finished => break,
        }
    }
}
```



## 共享调度器实现

任务元数据主要包含以下内容

- 任务指针

  > 由于地址空间隔离，只有任务所在的地址空间才可以解释任务指针
  >
  > 即使出现了错误的行为（如调度器觉得要继续执行，却切换了地址空间
  >
  > 执行器也没办法真正的执行起来

- 地址空间编号

- 硬件线程编号

除了任务数据之外比较重要的是地址空间

> 内核地址空间编号为0   用户地址空间从1开始增长